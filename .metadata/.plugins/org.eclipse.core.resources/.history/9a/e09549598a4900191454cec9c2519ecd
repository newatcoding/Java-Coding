package mar16;

public class LinkedList {
	private class Node {
		public int data;
		public Node next;
	}
	private Node rdrleft;
	private Node head;
	private Node tail;
	private int size;

	// o1
	public LinkedList() {
		head = tail = null;
		size = 0;
	}

	// on
	public void display() {
		Node temp = head;
		for (int i = 0; i < size; i++) {
			System.out.print(temp.data + " ");
			temp = temp.next;
		}
		System.out.println();
//		for(Node temp=head; temp!=null;temp=temp.next){
//			System.out.println(temp.data+" ");
//		}
//		System.out.println();
	}

	// o1
	private void handleAddWhenSizeIs0(int data) {
		Node nn = new Node();

		nn.data = data;
		nn.next = null;

		head = tail = nn;
		size = 1;
	}

	// o1
	public void addLast(int data) {
		if (size == 0) {
			handleAddWhenSizeIs0(data);
		} else {
			Node nn = new Node();

			nn.data = data;
			nn.next = null;

			tail.next = nn;

			tail = nn;
			size++;
		}
	}

	// o1
	public boolean isEmpty() {
		return size == 0;
	}

	// o1
	public int getSize() {
		return size;
	}

	// o1
	public int getFirst() {
		if (size == 0) {
			return -1;
		} else {
			return head.data;
		}
	}

	// o1
	public int getLast() {
		if (size == 0) {
			return -1;
		} else {
			return tail.data;
		}
	}

	// on
	private Node getNodeAt(int idx) {
		Node temp = head;
		for (int i = 0; i < idx; i++) {
			temp = temp.next;
		}
		return temp;
	}

	// o1
	private int handleRemoveWhenSizeIs1() {
		int temp = head.data;

		head = tail = null;
		size = 0;

		return temp;
	}

	// on
	public int removeAt(int idx) {
		if (idx < 0 || idx >= size) {
			return -1;
		} else if (idx == 0) {
			return removeFirst();
		} else if (idx == size - 1) {
			return removeLast();
		} else {
			Node nm1 = getNodeAt(idx - 1);
			Node n = nm1.next;
			Node np1 = n.next;

			nm1.next = np1;
			size--;

			int temp = n.data;
			return temp;
		}
	}

	// on
	public int removeLast() {
		if (size == 1) {
			return handleRemoveWhenSizeIs1();
		} else {
			Node sl = getNodeAt(size - 2);
			sl.next = null;

			int temp = tail.data;

			tail = sl;
			size--;

			return temp;
		}
	}

	// o1
	public int removeFirst() {
		if (size == 0) {
			return -1;
		} else if (size == 1) {
			return handleRemoveWhenSizeIs1();
		} else {
			Node oh = head;

			head = head.next;
			size--;

			int temp = oh.data;
			return temp;
		}
	}
	
    public void addFirst(int data)
    {
        if(size == 0)
        {
            handleAddWhenSizeIs0(data);
        }
        else 
        {
            // space
            Node nn = new Node();

            // dandn
            nn.data = data;
            nn.next = null;

            // connect
            nn.next = head;

            //summaries
            head = nn;
            size++;
        }
    }

    // on
    public void addAt(int data, int idx)
    {
        if (idx < 0 || idx > size)
        {
            return;
        }
        else if (idx == 0)
        {
            addFirst(data);
        }
        else if (idx == size)
        {
            addLast(data);
        }
        else
        {
            Node nm1 = getNodeAt(idx - 1);
            Node np1 = nm1.next;

            Node n = new Node();
            n.data = data;

            nm1.next = n;
            n.next = np1;
            size++;
        }
    }
    
    //on*n    //reverse data iteration
    
    public void rdi(){
    	int li=0;
    	int ri=size-1;
    	while(li<=ri){
    		Node left=getNodeAt(li);
    		Node right=getNodeAt(ri);
    		int temp=left.data;
    		left.data=right.data;
    		right.data=temp;
    		li++;
    		ri--;
    		
    	}
    }
    
    //on    //reverse pointer iteration
    public void rpi(){
    	Node prev=null;
    	Node curr=head;
    	Node next=head.next;
    	while(curr!=null){
    		curr.next=prev;
    		prev=curr;
    		curr=next;
    		if(next!=null){
    			next=next.next;
    		}
    	}
    	Node temp=head;
    	head=tail;
    	tail=temp;
    }
    //on
    private void displayReverse(Node node){
    	if(node==null){
    		return;
    	}
    	displayReverse(node.next);
    	System.out.print(node.data+" ");
    }
    public void displayReverse(){
    	displayReverse(head);
    	System.out.println();
    }
    
    //on
    private void rpr(Node node){
    	if(node==tail){
    		return;
    	}
    	rpr(node.next);
    	node.next.next=node;
    }
    public void rpr(){
    	rpr(head);
    	Node temp=head;
    	head=tail;
    	tail=temp;
    	tail.next=null;
    }
	
    
    //on  recursive data reverse
    private void rdr(Node right,int floor){
    	if(right==null){
    		return;
    	}
    	rdr(right.next,floor +1);
    	if(floor>=size/2){
    		
    		int  temp=right.data;
    		right.data=rdrleft.data;
    		rdrleft.data=temp;
    		
    		rdrleft=rdrleft.next;
    	}
    }
    
    public void rdr(){
    	rdrleft=head;
    	Node right=head;
    	rdr(right,0);
    }
    //on
    private boolean IsPallindrome(Node right){
    	if(right==null){
    		return true;
    	}
    	boolean br=IsPallindrome(right.next);
    	
    	if(br==true){
    	if(right.data!=rdrleft.data){
    		br=false;
    	}
    	rdrleft=rdrleft.next;
    	}
    	//boolean  mr=br==true && rdrleft.data==right.data; if mr and br is false the 
    	//condition in right will not be used saving time
    	return br;
    }
    public void IsPallindrome(){
    	rdrleft=head;
    	Node right=head;
    	boolean br=IsPallindrome(right);
    	if(br==true)
    		System.out.println("Pallindrome");
    	else
    		System.out.println("Not pallindrome");
    }
    
    //on
    private void fold(Node right,int floor){
    	if(right==null){
    		return;
    	}
    	fold(right.next,floor+1);
    	if(floor>size/2){
    		Node temp=rdrleft.next;
    		rdrleft.next=right;
    		right.next=temp;
    	}
    	if(floor==size/2){   //applied both for even and o
    	tail=right;
    	tail.next=null;
    	}
    	rdrleft=right.next;
    	
    }
    public void fold(){
    	rdrleft=head;
    	Node right=head;
    	fold(right,0);
    }
    
    //on
    private void unfold(Node left){
    	if(left.next==null){
    		head=tail=left;
    		return;
    	}
    	if(left.next.next==null){
    		head=left;
    		tail=left.next;
    		return;
    	}
    	
    	Node right=left.next;    //variable store
    	unfold(left.next.next);   //parameter
    	left.next=head;
    	tail.next=right;
    	head=left;
    	tail=right;
    	tail.next=null;
    }
    public void unfold(){
    	unfold(head);
    }
    
    public void Kreverse(int k){
    	
    	LinkedList prev=null;
    	while(this.size!=0){
    		LinkedList curr=new LinkedList();
    		for(int i=0;i<k;i++){
    			curr.addFirstnode(this.removeFirstnode());
    		}
    		if(prev==null){
    			prev=curr;
    		}
    		else{
    			prev.tail.next=curr.head;
    			prev.tail=curr.tail;
    			prev.size+=curr.size;
    		}
    	}
    	this.size=prev.size;
    	this.head=prev.head;
    	this.tail=prev.tail;
    }
    private void addFirstnode(Node node){
    	if(size==0){
    		head=tail=null;
    		size=1;
    	
    	}
    	else{
    		node.next=head;
    		head=tail;
    		size++;
    	}
    }
    private Node removeFirstnode(){
    	if(size==0){
    		return null;
    	}
    	else  if(size==1){
    		Node temp=head;
    		head=tail=null;
    		size=0;
    		return temp;
    	}
    	else{
    		Node oh=head;
    		head=head.next;
    		size--;
    		oh.next=null;
    		return oh;
    	}
    	
    }
    public static void main(String[] args) {
		LinkedList l = new LinkedList();
		l.addLast(10);
		l.addLast(20);
		l.addLast(30);
		l.addLast(40);
		l.addLast(50);
		l.addLast(60);
		l.addLast(70);
		l.addLast(80);
		l.addLast(90);
//		l.addLast(100);
		l.display(); // 10 20 30
//		l.addFirst(0);
//		l.addFirst(5);
//		l.display(); // 50 40 10 20 30
//		l.addAt(100, 3);
//		l.display(); // 50 40 10 100 20 30
//		l.removeFirst();
//		l.removeFirst();
//		l.display(); // 10 100 20 30
//		l.removeLast();
//		l.display(); // 10 100 20
//		l.addLast(200);
//		l.display(); // 10 100 20 200
//		l.removeAt(2);
//		l.display(); // 10 100 200
//		l.rdi();
//		l.display();
//		l.rpi();
//		l.display();
//		l.displayReverse();
//		l.rpr();
//		l.display();
//		l.rdi();
//		l.display();
//		l.rdr();
//		l.display();
//		l.IsPallindrome();
//		l.fold();
//		l.display();
//		l.addLast(25);
//		l.display();
//		l.fold();
//		l.display();
//		l.unfold();
//		l.display();
//		l.addLast(90);
//		l.display();
//		l.fold();
//		l.display();
//		l.unfold();
//		l.display();
		l.Kreverse(3);
		l.display();
		
	}
}
